)]}'
{"version":3,"file":"/packages/fast-render.js","sources":["fast-render/lib/utils.js","fast-render/lib/vendor/cookies.js","fast-render/lib/vendor/deepExtend.js","fast-render/lib/client/log.js","fast-render/lib/client/fast_render.js","fast-render/lib/client/ddp_update.js","fast-render/lib/client/data_handler.js","fast-render/lib/client/iron_router_support.js","fast-render/lib/client/auth.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+B;AACA,2C;AACA,gC;AACA,E;;AAEA,sC;AACA,mD;AACA,6D;AACA,E;;;;;;;;;;;;;;;;;;;ACRA,sD;;AAEA,G;AACA,qB;AACA,yC;AACA,E;AACA,mC;AACA,kC;AACA,yC;AACA,G;AACA,uB;AACA,iB;;AAEA,kD;AACA,uC;AACA,gE;AACA,M;;AAEA,gD;AACA,iC;AACA,mC;;AAEA,wB;AACA,iB;AACA,M;;AAEA,kC;AACA,yE;AACA,kC;AACA,S;;AAEA,mC;AACA,M;;AAEA,kD;AACA,uD;AACA,8F;;AAEA,sF;;AAEA,uB;AACA,M;;AAEA,8C;AACA,oD;AACA,M;;AAEA,sD;AACA,gB;AACA,mE;AACA,yE;AACA,4E;AACA,uG;AACA,U;AACA,M;;AAEA,4C;AACA,kG;AACA,M;;AAEA,uD;AACA,gC;AACA,iC;AACA,qF;AACA,8D;AACA,S;;AAEA,wD;AACA,gG;AACA,S;;AAEA,uB;AACA,M;;AAEA,oE;AACA,sC;AACA,mF;AACA,gC;;AAEA,6C;AACA,oE;AACA,0E;AACA,2F;AACA,wD;;AAEA,4B;AACA,M;;AAEA,oE;AACA,8B;AACA,4E;;AAEA,uD;AACA,sF;;AAEA,4D;AACA,8D;AACA,a;AACA,S;;AAEA,4B;AACA,M;;AAEA,wE;AACA,kG;AACA,uD;;AAEA,oE;AACA,mF;;AAEA,gB;AACA,4E;AACA,8E;AACA,U;AACA,M;;AAEA,uC;AACA,sF;AACA,iE;AACA,M;;AAEA,uC;AACA,kD;AACA,mE;AACA,M;;AAEA,4C;;AAEA,kB;AACA,qD;AACA,gD;AACA,2C;AACA,gD;AACA,8E;AACA,8D;AACA,+C;AACA,S;AACA,yF;AACA,kC;AACA,Y;AACA,iC;AACA,K;AACA,K;;AAEA,2B;AACA,yB;AACA,sB;;;;;;;;;;;;;;;;;;;AClJA,8F;AACA,uC;AACA,gF;AACA,Y;AACA,gC;AACA,mB;AACA,2C;AACA,+C;AACA,kC;AACA,oC;AACA,mC;AACA,wC;AACA,oB;AACA,sC;AACA,oC;AACA,oC;AACA,wC;AACA,kC;AACA,gC;AACA,oC;AACA,mC;AACA,Q;AACA,gB;AACA,oC;AACA,gD;AACA,U;AACA,iC;AACA,wB;AACA,6C;AACA,U;AACA,kC;AACA,iD;AACA,U;AACA,mC;AACA,yD;AACA,U;AACA,8B;AACA,uF;AACA,U;AACA,uC;AACA,sE;AACA,wB;AACA,W;AACA,e;AACA,kI;AACA,0B;AACA,a;AACA,uB;AACA,wB;AACA,W;AACA,kB;AACA,6B;AACA,2D;AACA,S;AACA,Q;AACA,sC;AACA,oB;AACA,kC;AACA,Y;AACA,K;AACA,mE;AACA,iB;AACA,K;AACA,uB;AACA,oB;AACA,U;AACA,K;AACA,8B;AACA,6C;AACA,+B;AACA,6B;AACA,+B;AACA,gC;AACA,oB;AACA,W;AACA,qG;AACA,8B;AACA,kC;AACA,2D;AACA,oB;AACA,kE;AACA,a;AACA,iC;AACA,yD;AACA,0C;AACA,gC;AACA,W;AACA,S;AACA,O;AACA,K;AACA,kB;AACA,G;;;;;;;;;;;;;;;;;;AC3FA,mD;AACA,K;AACA,oC;AACA,0C;AACA,6C;AACA,sC;AACA,0C;AACA,G;AACA,C;;AAEA,yB;AACA,uC;AACA,E;;AAEA,0B;AACA,qC;AACA,E;;;;;;;;;;;;;;;;;;AChBA,gB;;AAEA,4D;AACA,wC;AACA,oC;AACA,iD;AACA,0F;AACA,G;;AAEA,gD;AACA,4D;AACA,K;AACA,E;;AAEA,gE;AACA,qB;;;;;;;;;;;;;;;;;;ACfA,gD;AACA,wB;AACA,S;AACA,C;;AAEA,mC;;AAEA,oE;AACA,0D;AACA,0B;;AAEA,6D;AACA,+B;AACA,oD;AACA,+E;AACA,uE;AACA,6E;AACA,sC;AACA,+E;AACA,0C;AACA,kG;AACA,2B;AACA,0D;AACA,yB;AACA,iE;AACA,gC;AACA,8B;AACA,S;AACA,O;AACA,K;;AAEA,oE;AACA,6C;AACA,gF;AACA,wC;AACA,yE;AACA,0B;AACA,4D;AACA,wD;AACA,kE;AACA,+D;;AAEA,2F;AACA,wE;AACA,S;AACA,S;AACA,K;;AAEA,sF;AACA,8D;AACA,qD;AACA,oC;AACA,K;AACA,G;;AAEA,8C;AACA,E;;AAEA,mD;AACA,iD;AACA,uB;;AAEA,uF;AACA,oC;AACA,kF;AACA,8C;AACA,wD;AACA,kC;AACA,G;;AAEA,kB;;AAEA,6D;AACA,+B;AACA,gH;AACA,sC;AACA,oE;AACA,6C;AACA,gE;AACA,K;AACA,G;;AAEA,sC;AACA,E;;;;;;;;;;;;;;;;;;ACnFA,0C;AACA,wC;;AAEA,oC;AACA,gD;AACA,qD;AACA,yC;AACA,uC;AACA,8F;AACA,6B;AACA,6D;AACA,0B;AACA,+C;AACA,yD;AACA,kB;AACA,yC;AACA,W;AACA,gB;AACA,2F;AACA,S;AACA,S;AACA,O;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;ACvBA,mC;;AAEA,4C;AACA,yD;AACA,wD;AACA,0F;;AAEA,wD;AACA,kE;AACA,2D;AACA,uD;AACA,kB;AACA,0B;AACA,iD;AACA,6B;AACA,O;AACA,U;AACA,2B;AACA,G;AACA,E;;AAEA,yC;AACA,2C;AACA,kB;AACA,yB;AACA,mC;AACA,6B;AACA,8E;AACA,uF;AACA,+E;AACA,wD;AACA,kE;AACA,uD;AACA,yE;AACA,2D;;AAEA,iB;AACA,kD;AACA,6C;;AAEA,sF;AACA,Y;AACA,yB;AACA,oB;AACA,O;AACA,K;AACA,U;AACA,oD;AACA,G;AACA,E;;AAEA,oB;AACA,wC;AACA,2B;AACA,sB;AACA,C;;;;;;;;;;;;;;;;;;ACvDA,sC;AACA,2B;AACA,6B;AACA,iC;AACA,I;AACA,+D;AACA,4E;AACA,0B;AACA,gB;AACA,2E;AACA,yF;;AAEA,uD;AACA,oB;AACA,oC;AACA,W;AACA,c;AACA,6C;AACA,O;AACA,K;AACA,K;AACA,Q;AACA,sD;AACA,uC;AACA,C","sourcesContent":["EncodeEJSON = function(ejson) {\n  var ejsonString = EJSON.stringify(ejson);\n  return encodeURI(ejsonString);\n};\n\nDecodeEJSON = function(encodedEjson) {\n  var decodedEjsonString = decodeURI(encodedEjson);\n  return EJSON.fromJSONValue(JSON.parse(decodedEjsonString));\n};\n","// Picked from: https://github.com/ScottHamper/Cookies\n\n/*!\n * Cookies.js - 0.3.1\n * Wednesday, April 24 2013 @ 2:28 AM EST\n *\n * Copyright (c) 2013, Scott Hamper\n * Licensed under the MIT license,\n * http://www.opensource.org/licenses/MIT\n */\n(function (undefined) {\n    'use strict';\n\n    var Cookies = function (key, value, options) {\n        return arguments.length === 1 ?\n            Cookies.get(key) : Cookies.set(key, value, options);\n    };\n\n    // Allows for setter injection in unit tests\n    Cookies._document = document;\n    Cookies._navigator = navigator;\n\n    Cookies.defaults = {\n        path: '/'\n    };\n\n    Cookies.get = function (key) {\n        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {\n            Cookies._renewCache();\n        }\n\n        return Cookies._cache[key];\n    };\n\n    Cookies.set = function (key, value, options) {\n        options = Cookies._getExtendedOptions(options);\n        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);\n\n        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);\n\n        return Cookies;\n    };\n\n    Cookies.expire = function (key, options) {\n        return Cookies.set(key, undefined, options);\n    };\n\n    Cookies._getExtendedOptions = function (options) {\n        return {\n            path: options && options.path || Cookies.defaults.path,\n            domain: options && options.domain || Cookies.defaults.domain,\n            expires: options && options.expires || Cookies.defaults.expires,\n            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure\n        };\n    };\n\n    Cookies._isValidDate = function (date) {\n        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());\n    };\n\n    Cookies._getExpiresDate = function (expires, now) {\n        now = now || new Date();\n        switch (typeof expires) {\n            case 'number': expires = new Date(now.getTime() + expires * 1000); break;\n            case 'string': expires = new Date(expires); break;\n        }\n\n        if (expires && !Cookies._isValidDate(expires)) {\n            throw new Error('`expires` parameter cannot be converted to a valid Date instance');\n        }\n\n        return expires;\n    };\n\n    Cookies._generateCookieString = function (key, value, options) {\n        key = encodeURIComponent(key);\n        value = (value + '').replace(/[^!#$&-+\\--:<-\\[\\]-~]/g, encodeURIComponent);\n        options = options || {};\n\n        var cookieString = key + '=' + value;\n        cookieString += options.path ? ';path=' + options.path : '';\n        cookieString += options.domain ? ';domain=' + options.domain : '';\n        cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';\n        cookieString += options.secure ? ';secure' : '';\n\n        return cookieString;\n    };\n\n    Cookies._getCookieObjectFromString = function (documentCookie) {\n        var cookieObject = {};\n        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];\n\n        for (var i = 0; i < cookiesArray.length; i++) {\n            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);\n\n            if (cookieObject[cookieKvp.key] === undefined) {\n                cookieObject[cookieKvp.key] = cookieKvp.value;\n            }\n        }\n\n        return cookieObject;\n    };\n\n    Cookies._getKeyValuePairFromCookieString = function (cookieString) {\n        // \"=\" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`\n        var separatorIndex = cookieString.indexOf('=');\n\n        // IE omits the \"=\" when the cookie value is an empty string\n        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;\n\n        return {\n            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),\n            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))\n        };\n    };\n\n    Cookies._renewCache = function () {\n        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);\n        Cookies._cachedDocumentCookie = Cookies._document.cookie;\n    };\n\n    Cookies._areEnabled = function () {\n        return Cookies._navigator.cookieEnabled ||\n            Cookies.set('cookies.js', 1).get('cookies.js') === '1';\n    };\n\n    Cookies.enabled = Cookies._areEnabled();\n\n    // AMD support\n    if (typeof define === 'function' && define.amd) {\n        define(function () { return Cookies; });\n    // CommonJS and Node.js module support.\n    } else if (typeof exports !== 'undefined') {\n        // Support Node.js specific `module.exports` (which can be a function)\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = Cookies;\n        }\n        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)\n        exports.Cookies = Cookies;\n    } else {\n        window.Cookies = Cookies;\n    }\n})();\n\n//clearning form the window\nCookies = window.Cookies;\ndelete window.Cookies;\n","// stolen from: http://stackoverflow.com/questions/9399365/deep-extend-like-jquerys-for-nodejs\nDeepExtend = deepExtend = function () {\n  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false,\n      toString = Object.prototype.toString,\n      hasOwn = Object.prototype.hasOwnProperty,\n      push = Array.prototype.push,\n      slice = Array.prototype.slice,\n      trim = String.prototype.trim,\n      indexOf = Array.prototype.indexOf,\n      class2type = {\n        \"[object Boolean]\": \"boolean\",\n        \"[object Number]\": \"number\",\n        \"[object String]\": \"string\",\n        \"[object Function]\": \"function\",\n        \"[object Array]\": \"array\",\n        \"[object Date]\": \"date\",\n        \"[object RegExp]\": \"regexp\",\n        \"[object Object]\": \"object\"\n      },\n      jQuery = {\n        isFunction: function (obj) {\n          return jQuery.type(obj) === \"function\"\n        },\n        isArray: Array.isArray ||\n        function (obj) {\n          return jQuery.type(obj) === \"array\"\n        },\n        isWindow: function (obj) {\n          return obj != null && obj == obj.window\n        },\n        isNumeric: function (obj) {\n          return !isNaN(parseFloat(obj)) && isFinite(obj)\n        },\n        type: function (obj) {\n          return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\"\n        },\n        isPlainObject: function (obj) {\n          if (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType) {\n            return false\n          }\n          try {\n            if (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n              return false\n            }\n          } catch (e) {\n            return false\n          }\n          var key;\n          for (key in obj) {}\n          return key === undefined || hasOwn.call(obj, key)\n        }\n      };\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {};\n      i = 2;\n    }\n    if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\n      target = {}\n    }\n    if (length === i) {\n      target = this;\n      --i;\n    }\n    for (i; i < length; i++) {\n      if ((options = arguments[i]) != null) {\n        for (name in options) {\n          src = target[name];\n          copy = options[name];\n          if (target === copy) {\n            continue\n          }\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : []\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            }\n            // WARNING: RECURSION\n            target[name] = deepExtend(deep, clone, copy);\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n    return target;\n  }","Log = function function_name(message/*, args..*/) {\n  if(\n    typeof console != 'undefined' &&\n    typeof localStorage != 'undefined' && \n    localStorage.getItem('__frlog') == \"1\") {\n    arguments[0] = arguments[0] + \":\";\n    console.log.apply(console, arguments);\n  }\n}\n\nLog.enable = function() {\n  localStorage.setItem('__frlog', \"1\");\n};\n\nLog.disable = function() {\n  localStorage.removeItem('__frlog');\n};","FastRender = {};\n\nFastRender.completeSubscriptions = function(subscriptions) {\n  if(typeof subscriptions == 'string') {\n    subscriptions = [subscriptions];\n  } else if(subscriptions.constructor != Array) {\n    throw new Error('subscriptions params should be either a string or array of strings');\n  }\n\n  subscriptions.forEach(function(subscription) {\n    __fast_render_config.subscriptions[subscription] = true;\n  });\n};\n\nFastRender.enabled = typeof __fast_render_config != 'undefined';\nFastRender.Log = Log;","if(typeof __fast_render_config == 'undefined') {\n  Log('NO_FAST_RENDER');\n  return;\n}\n\nvar revertedBackToOriginal = false;\n\nvar originalLivedataData = Meteor.default_connection._livedata_data;\nMeteor.default_connection._livedata_data = function(msg) {\n  Log('DDP_RECIEVE', msg);\n\n  //if we've completed our tasks, no need of special handling\n  if(!revertedBackToOriginal) {\n    //we are inserting docs to a collection manually\n    //but when the data comes from the subscription, it will also try to insert\n    //but since there are some exiting data, meteor throws an execption\n    //  serverDoc check is to see, if this doc is releated to an simulation, \n    //  if so it's better to ignore it\n    var serverDoc = Meteor._get(this._serverDocuments, msg.collection, msg.id);\n    if(!serverDoc && msg.msg == 'added') {\n      var localCollection = Meteor.default_connection._mongo_livedata_collections[msg.collection];\n      if(localCollection) {\n        var existingDoc = localCollection.findOne(msg.id);\n        if(existingDoc) {\n          msg.fields = DeepExtend(true, existingDoc, msg.fields);\n          delete msg.fields._id;\n          msg.msg = \"changed\";\n        }\n      }\n    }\n\n    //This will take care of cleaning special subscription handling \n    //after the actual subscription comes out\n    if(msg.msg == 'ready' && !msg.frGen && __fast_render_config.subscriptions) {\n      msg.subs.forEach(function(subId) {\n        var subscription = __fast_render_config.subscriptionIdMap[subId];\n        if(subscription) {\n          Log('DELETING_SUBSCRIPTION', subscription, subId);\n          //we don't need to handle specially after this\n          delete __fast_render_config.subscriptions[subscription];\n          delete __fast_render_config.subscriptionIdMap[subId];\n\n          //need to track the loaded subscription, specially for handling in the ironRouter\n          __fast_render_config.loadedSubscriptions[subscription] = true;\n        }\n      });\n    }\n\n    //if all the subscriptions have been processed, there is no need to keep hijacking\n    if(EJSON.equals(__fast_render_config.subscriptions, {})) {\n      Log('REVERTING_BACK_TO_ORIGINAL_DDP_HANDLING');\n      revertedBackToOriginal = true;\n    }\n  }\n\n  return originalLivedataData.call(this, msg);\n};\n\nvar originalSend = Meteor.default_connection._send;\nMeteor.default_connection._send = function(msg) {\n  Log(\"DDP_SEND\", msg);\n\n  //if looking for connect again to the server, we must need to revert back to original\n  //to prevent some weird DDP issues\n  //  normally it is already reverted, but user may added subscriptions in server,\n  //  which are not subscribed from the client\n  if(msg.msg == 'connect' && msg.session != undefined) {\n    revertedBackToOriginal = true;\n  }\n\n  var self = this;\n\n  //if we've completed our tasks, no need of special handling\n  if(!revertedBackToOriginal) {\n    if(msg.msg == 'sub' && __fast_render_config.subscriptions && __fast_render_config.subscriptions[msg.name]) {\n      Log('FAKE_SUB_READY', msg.name);\n      self._livedata_data({msg:\"ready\",subs:[msg.id], frGen: true});\n      //add the messageId to be handled later\n      __fast_render_config.subscriptionIdMap[msg.id] = msg.name;\n    }\n  }\n\n  return originalSend.call(this, msg);\n};","__init_fast_render = function(ejsonJson) {\n  var initData = DecodeEJSON(ejsonJson);\n\n  //loading data into the collection\n  for(var collName in initData.collectionData) {\n    var collData = initData.collectionData[collName];\n    collData.forEach(function(itemList) {\n      itemList.forEach(function(item) {\n        var localCollection = Meteor.default_connection._mongo_livedata_collections[collName];\n        if(localCollection) {\n          var exitingDoc = localCollection.findOne(item._id);\n          if(exitingDoc) {\n            DeepExtend(true, exitingDoc, item);\n            localCollection.update(item._id, exitingDoc);\n          } else {\n            localCollection.insert(item);\n          }\n        } else {\n          console.warn('fast-route data found, but no collection exists for: ' + collName);\n        }\n      });\n    });\n  }\n}","if(!Package['iron-router']) return;\n\n//track whether inside the ironRouter or not\n//useful for identifying this inside the Meteor.subscribe\nvar insideIronRouter = new Meteor.EnvironmentVariable();\nvar RouteController = FastRender.RouteController = Package['iron-router'].RouteController;\n\n//IR 0.8 comes with method named `_run` instead of `run`\nvar runMethodName = RouteController.prototype._run? \"_run\": \"run\";\nvar originalRun = RouteController.prototype[runMethodName];\nRouteController.prototype[runMethodName] = function() {\n  var self = this;\n  if(FastRender.enabled) {\n    insideIronRouter.withValue(true, function() {\n      originalRun.call(self);\n    });\n  } else {\n    originalRun.call(this);\n  }\n};\n\nvar originalSubscribe = Meteor.subscribe;\nMeteor.subscribe = function(subscription) {\n  var condition = \n    FastRender.enabled &&\n    //need to inside the ironRouter\n    insideIronRouter.get() &&\n    //path loaded from the server and the local Router path should be the same\n    //We can't simply use Router.current().path, it will give some weird deps behaviour\n    //which will result subscriptions stop everytime even they are not meant to\n    getPath() == __fast_render_config.serverRoutePath &&\n    //fast render have been registered to handle this subscription\n    __fast_render_config.subscriptions[subscription] &&\n    //subscription not yet actually loaded (this may call multiple times)\n    !__fast_render_config.loadedSubscriptions[subscription]\n\n  if(condition) {\n    Log('APPLY_IR_SUB_CORRECTIONS', subscription);\n    originalSubscribe.apply(this, arguments);\n\n    //ironRouter call .ready() and and if it's true he think subscription is completed\n    return {\n      ready: function() {\n        return true;\n      }\n    }\n  } else {\n    return originalSubscribe.apply(this, arguments);\n  }\n};\n\nfunction getPath() {\n  var url = document.createElement('a');\n  url.href = location.href;\n  return url.pathname;\n}","if(typeof Meteor.user == 'function') {\n  Deps.autorun(function() {\n    var user = Meteor.user();\n    var status = Meteor.status();\n    \n    //we don't need to clean cookies if we've not connected yet\n    //this is very usefull when testing with connecting a bad ddp connection\n    if(status.connected) {\n      if(user) {\n        var loginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n        var loginTokenExpires = Meteor._localStorage.getItem('Meteor.loginTokenExpires');\n\n        Cookies.set('meteor_login_token', loginToken, {\n          path: '/',\n          expires: loginTokenExpires\n        });\n      } else {\n        Cookies.expire('meteor_login_token');\n      }\n    }\n  });\n} else {\n  //make sure cookie is deleted (if previously setted)\n  Cookies.expire('meteor_login_token');\n}\n"]}